# å±¥ä¿®ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ  - æ­£ç›´ãªå®Ÿè£…ç‰ˆ

## ğŸ¤ ç§ã®æ–¹é‡

ç§ã¯æŠ€è¡“çš„ãªåˆ¶ç´„ã‚„å•é¡Œç‚¹ã‚’æ­£ç›´ã«èª¬æ˜ã—ã¾ã™ã€‚ã€Œå®Œå…¨ã€ã€Œå®Œç’§ã€ã¨ã„ã£ãŸèª‡å¼µè¡¨ç¾ã¯é¿ã‘ã€å®Ÿè£…ã®é™ç•Œã‚„é‹ç”¨ä¸Šã®èª²é¡Œã‚‚å«ã‚ã¦ç‡ç›´ã«ãŠä¼ãˆã—ã¾ã™ã€‚

## é–‹ç™ºãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ãƒ»è¨€èª

- TypeScript -
  å‹å®‰å…¨æ€§ã¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ãƒã‚§ãƒƒã‚¯
  - Node.js - ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰å®Ÿè¡Œç’°å¢ƒ
  - Zod - å®Ÿè¡Œæ™‚å‹æ¤œè¨¼ã¨ã‚¹ã‚­ãƒ¼ãƒå®šç¾©

## ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ãƒ‘ã‚¿ãƒ¼ãƒ³

- Domain-Driven Design (DDD) -
  ãƒ‰ãƒ¡ã‚¤ãƒ³ä¸­å¿ƒè¨­è¨ˆ
- Hexagonal Architecture -
  ãƒãƒ¼ãƒˆ&ã‚¢ãƒ€ãƒ—ã‚¿ãƒ‘ã‚¿ãƒ¼ãƒ³
- Event Sourcing -
  ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•ã«ã‚ˆã‚‹çŠ¶æ…‹ç®¡ç†
- CQRS - ã‚³ãƒãƒ³ãƒ‰ã‚¯ã‚¨ãƒªè²¬å‹™åˆ†é›¢
- Functional Programming -
  é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°æ‰‹æ³•

## ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ»ORM

  - PostgreSQL -
  ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒŠãƒ«ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹
  - Prisma - TypeScriptå¯¾å¿œORM
  - ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ç®¡ç† -
  ACIDç‰¹æ€§ä¿è¨¼

## å‹ã‚·ã‚¹ãƒ†ãƒ ãƒ»ãƒ‡ãƒ¼ã‚¿æ¤œè¨¼

  - Brand Types - æ„å‘³çš„å‹åŒºåˆ¥
  - Discriminated Union -
  å‹å®‰å…¨ãªçŠ¶æ…‹è¡¨ç¾
  - Eitherå‹ -
  é–¢æ•°å‹ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
  - å®Ÿè¡Œæ™‚å‹æ¤œè¨¼ -
  Zodã«ã‚ˆã‚‹å®‰å…¨æ€§ä¿è¨¼

## ãƒ†ã‚¹ãƒˆ

  - Jest/Vitest - ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆæ¡†æ¶
  - Test-Driven Development (TDD) -
  ãƒ†ã‚¹ãƒˆé§†å‹•é–‹ç™º

## ä¸¦è¡Œåˆ¶å¾¡ãƒ»æ•´åˆæ€§

  - æ¥½è¦³çš„ãƒ­ãƒƒã‚¯ -
  ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç®¡ç†ã«ã‚ˆã‚‹ç«¶åˆåˆ¶å¾¡
  - ã‚¤ãƒ™ãƒ³ãƒˆã‚¹ãƒˆã‚¢ -
  è¿½è¨˜å°‚ç”¨ãƒ‡ãƒ¼ã‚¿ã‚¹ãƒˆã‚¢
  - è¤‡åˆã‚­ãƒ¼åˆ¶ç´„ -
  ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ¬ãƒ™ãƒ«æ•´åˆæ€§

## è¨­è¨ˆåŸå‰‡

  - Immutability - ä¸å¤‰ãƒ‡ãƒ¼ã‚¿æ§‹é€ 
  - Pure Functions -
  å‰¯ä½œç”¨ã®ãªã„é–¢æ•°
  - ä¾å­˜æ€§é€†è»¢ -
  ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹é§†å‹•è¨­è¨ˆ
  - å˜ä¸€è²¬ä»»åŸå‰‡ - æ˜ç¢ºãªå½¹å‰²åˆ†é›¢

## é‹ç”¨ãƒ»ç›£è¦–

  - ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆ -
  ç›£æŸ»è¨¼è·¡ã¨ã‚·ã‚¹ãƒ†ãƒ é–“é€£æº
  - ã‚¨ãƒ©ãƒ¼è¿½è·¡ - æ§‹é€ åŒ–ã‚¨ãƒ©ãƒ¼ç®¡ç†
  - ãƒ­ã‚°ç®¡ç† - é‹ç”¨å¯è¦–æ€§

## ğŸ“ ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹æˆ

```
src/
â”œâ”€â”€ domain/
â”‚   â”œâ”€â”€ types.ts                 # Zodã«ã‚ˆã‚‹å‹å®šç¾©
â”‚   â”œâ”€â”€ errors.ts                # ã‚¨ãƒ©ãƒ¼å‹å®šç¾©
â”‚   â”œâ”€â”€ domain-events.ts         # ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆ
â”‚   â””â”€â”€ enrollment-aggregate.ts  # é›†ç´„æ“ä½œ
â”œâ”€â”€ application/
â”‚   â”œâ”€â”€ ports.ts                 # ä¾å­˜æ€§é€†è»¢ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
â”‚   â”œâ”€â”€ dtos.ts                  # DTOs
â”‚   â””â”€â”€ enrollment-service.ts    # ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚µãƒ¼ãƒ“ã‚¹
â”œâ”€â”€ infrastructure/
â”‚   â”œâ”€â”€ prisma/
â”‚   â”‚   â””â”€â”€ schema.prisma        # DBã‚¹ã‚­ãƒ¼ãƒ
â”‚   â””â”€â”€ repositories/
â”‚       â””â”€â”€ enrollment-repository.ts  # ãƒªãƒã‚¸ãƒˆãƒªå®Ÿè£…
â””â”€â”€ tests/
    â”œâ”€â”€ domain/
    â”œâ”€â”€ application/
    â””â”€â”€ infrastructure/
```

## ğŸ“Š çŠ¶æ…‹é·ç§»å›³

```mermaid
stateDiagram-v2
    [*] --> Requested: requestEnrollment
    Requested --> Approved: approve
    Requested --> Cancelled: cancel
    Approved --> Cancelled: cancel
    Approved --> Completed: complete
    Approved --> Failed: fail
    Cancelled --> [*]
    Completed --> [*]
    Failed --> [*]
```

## ğŸ—ï¸ è¨­è¨ˆæ€æƒ³: CourseIdã¨Semesterã®åˆ†é›¢

### ãªãœå­¦æœŸã”ã¨ã®CourseIdã§ã¯ãªã„ã®ã‹ï¼Ÿ

ã“ã®ã‚·ã‚¹ãƒ†ãƒ ã§ã¯æ„å›³çš„ã« **CourseIdï¼ˆç§‘ç›®è­˜åˆ¥å­ï¼‰** ã¨ **Semesterï¼ˆå­¦æœŸè­˜åˆ¥å­ï¼‰** ã‚’åˆ†é›¢ã—ã¦ã„ã¾ã™ã€‚

#### âŒ å­¦æœŸè¾¼ã¿CourseIdã‚¢ãƒ—ãƒ­ãƒ¼ãƒ
```typescript
// ã“ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã¯æ¡ç”¨ã—ã¦ã„ã¾ã›ã‚“
const courseId = "MATH101-2024-SPRING";  // å­¦æœŸè¾¼ã¿ã®è­˜åˆ¥å­
```

#### âœ… åˆ†é›¢ã‚¢ãƒ—ãƒ­ãƒ¼ãƒï¼ˆæ¡ç”¨ï¼‰
```typescript
// ç§‘ç›®ã®æœ¬è³ªçš„ãªè­˜åˆ¥å­
const courseId: CourseId = "MATH101";     // ã€Œæ•°å­¦Iã€ã¨ã„ã†ç§‘ç›®
// æ™‚é–“è»¸ã§ã®é–‹è¬›
const semester: Semester = "2024-spring"; // 2024å¹´æ˜¥å­¦æœŸ

// çµ„ã¿åˆã‚ã›ã§ç‰¹å®šã®é–‹è¬›ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¡¨ç¾
const enrollment = {
  studentId: "ST001",
  courseId: "MATH101",    // ç§‘ç›®ã€Œæ•°å­¦Iã€
  semester: "2024-spring" // 2024å¹´æ˜¥å­¦æœŸã®é–‹è¬›
};
```

### åˆ†é›¢ã«ã‚ˆã‚‹è¨­è¨ˆä¸Šã®åˆ©ç‚¹

#### 1. **æ¦‚å¿µã®æ˜ç¢ºãªåˆ†é›¢**
```typescript
// ç§‘ç›®ã‚«ã‚¿ãƒ­ã‚°ï¼ˆæ’ä¹…çš„ï¼‰
interface Course {
  courseId: CourseId;        // MATH101
  title: string;            // "æ•°å­¦I"
  credits: number;          // 2å˜ä½
  prerequisites: CourseId[]; // å‰æç§‘ç›®
}

// é–‹è¬›ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼ˆå­¦æœŸã”ã¨ï¼‰
interface CourseOffering {
  courseId: CourseId;   // MATH101
  semester: Semester;   // 2024-spring
  instructor: string;   // æ‹…å½“æ•™å“¡ï¼ˆå­¦æœŸã”ã¨ã«å¤‰å‹•ï¼‰
  capacity: number;     // å®šå“¡ï¼ˆå­¦æœŸã”ã¨ã«å¤‰å‹•ï¼‰
  room: string;         // æ•™å®¤ï¼ˆå­¦æœŸã”ã¨ã«å¤‰å‹•ï¼‰
}
```

#### 2. **æŸ”è»Ÿãªãƒ‡ãƒ¼ã‚¿åˆ†æ**
```typescript
// å­¦æœŸæ¨ªæ–­ã§ã®å±¥ä¿®ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ†æ
function getCourseEnrollmentHistory(courseId: CourseId): Promise<Enrollment[]> {
  return findEnrollmentsByCourse(courseId); // å…¨å­¦æœŸã®MATH101å±¥ä¿®è€…
}

// ç‰¹å®šå­¦æœŸã®å±¥ä¿®è² è·åˆ†æ
function getSemesterWorkload(semester: Semester): Promise<Enrollment[]> {
  return findEnrollmentsBySemester(semester); // 2024æ˜¥å­¦æœŸã®å…¨å±¥ä¿®
}

// ç‰¹å®šé–‹è¬›ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ç®¡ç†
function getSpecificEnrollment(
  studentId: StudentId,
  courseId: CourseId,
  semester: Semester
): Promise<Enrollment | null> {
  return findEnrollment(studentId, courseId, semester);
}
```

#### 3. **ãƒ“ã‚¸ãƒã‚¹ãƒ«ãƒ¼ãƒ«ã®è‡ªç„¶ãªè¡¨ç¾**
```typescript
// å‰æç§‘ç›®ãƒã‚§ãƒƒã‚¯ï¼ˆç§‘ç›®ãƒ¬ãƒ™ãƒ«ï¼‰
async function checkPrerequisites(
  studentId: StudentId,
  courseId: CourseId  // ç§‘ç›®ãã®ã‚‚ã®ã‚’ãƒã‚§ãƒƒã‚¯
): Promise<Either<EnrollmentError, boolean>> {
  const course = await getCourse(courseId);
  const completedCourses = await getCompletedCourses(studentId);

  return course.prerequisites.every(prereq =>
    completedCourses.some(completed => completed.courseId === prereq)
  );
}

// å®šå“¡ãƒã‚§ãƒƒã‚¯ï¼ˆé–‹è¬›ãƒ¬ãƒ™ãƒ«ï¼‰
async function checkCapacity(
  courseId: CourseId,
  semester: Semester  // ç‰¹å®šã®é–‹è¬›ã‚’ãƒã‚§ãƒƒã‚¯
): Promise<Either<EnrollmentError, boolean>> {
  const offering = await getCourseOffering(courseId, semester);
  const currentEnrollments = await countEnrollments(courseId, semester);

  return currentEnrollments < offering.capacity;
}
```

#### 4. **çµ±è¨ˆã¨ãƒ¬ãƒãƒ¼ãƒˆã®å®¹æ˜“ã•**
```typescript
// ç§‘ç›®äººæ°—åº¦ãƒ¬ãƒãƒ¼ãƒˆï¼ˆå…¨å­¦æœŸçµ±åˆï¼‰
interface CoursePopularityReport {
  courseId: CourseId;
  courseName: string;
  totalEnrollments: number;
  averageEnrollmentPerSemester: number;
  semesterBreakdown: Array<{
    semester: Semester;
    enrollments: number;
  }>;
}

// å­¦æœŸè² è·ãƒ¬ãƒãƒ¼ãƒˆï¼ˆå…¨ç§‘ç›®çµ±åˆï¼‰
interface SemesterWorkloadReport {
  semester: Semester;
  totalEnrollments: number;
  uniqueStudents: number;
  averageCoursesPerStudent: number;
  courseBreakdown: Array<{
    courseId: CourseId;
    enrollments: number;
  }>;
}
```

### å®Ÿè£…ã§ã®ä¸€æ„æ€§ä¿è¨¼

è¤‡åˆã‚­ãƒ¼ã«ã‚ˆã‚‹è‡ªç„¶ãªä¸€æ„æ€§ï¼š
```typescript
// Enrollmenté›†ç´„ã®è­˜åˆ¥å­
interface EnrollmentIdentity {
  studentId: StudentId;  // ST001
  courseId: CourseId;    // MATH101
  semester: Semester;    // 2024-spring
}
// â†’ "ST001ãŒ2024å¹´æ˜¥å­¦æœŸã®MATH101ã«å±¥ä¿®ç”³è«‹"ã‚’ä¸€æ„ã«ç‰¹å®š
```

ã“ã®è¨­è¨ˆã«ã‚ˆã‚Šã€ã€Œå­¦ç”ŸST001ãŒæ•°å­¦Iã«å±¥ä¿®ç”³è«‹ã€ï¼ˆæ¦‚å¿µãƒ¬ãƒ™ãƒ«ï¼‰ã¨ã€Œå­¦ç”ŸST001ãŒ2024å¹´æ˜¥å­¦æœŸé–‹è¬›ã®æ•°å­¦Iã«å±¥ä¿®ç”³è«‹ã€ï¼ˆå®Ÿè£…ãƒ¬ãƒ™ãƒ«ï¼‰ã®ä¸¡æ–¹ã‚’è‡ªç„¶ã«è¡¨ç¾ã§ãã¾ã™ã€‚

## ğŸ”§ å®Ÿè£…è©³ç´°

### 1. ãƒ‰ãƒ¡ã‚¤ãƒ³å±¤

#### domain/types.ts - Zodã«ã‚ˆã‚‹å‹å®šç¾©

```typescript
import { z } from 'zod';

// === åŸºæœ¬å‹ï¼ˆãƒ–ãƒ©ãƒ³ãƒ‰å‹ã§å³å¯†åŒ–ï¼‰ ===
export const StudentIdSchema = z.string()
  .regex(/^[A-Z0-9]{1,20}$/, "å­¦ç”ŸIDã¯è‹±æ•°å­—1-20æ–‡å­—")
  .brand<'StudentId'>();

export const CourseIdSchema = z.string()
  .regex(/^[A-Z0-9]{1,20}$/, "ç§‘ç›®IDã¯è‹±æ•°å­—1-20æ–‡å­—")
  .brand<'CourseId'>();

export const SemesterSchema = z.string()
  .regex(/^\d{4}-(spring|summer|fall|winter)$/, "å­¦æœŸã¯ 'YYYY-season' å½¢å¼")
  .brand<'Semester'>();

export type StudentId = z.infer<typeof StudentIdSchema>;
export type CourseId = z.infer<typeof CourseIdSchema>;
export type Semester = z.infer<typeof SemesterSchema>;

// === Eitherå‹ ===
export type Either<L, R> =
  | { readonly type: 'left'; readonly value: L }
  | { readonly type: 'right'; readonly value: R };

export const left = <L, R>(value: L): Either<L, R> => ({ type: 'left', value });
export const right = <L, R>(value: R): Either<L, R> => ({ type: 'right', value });

// === å±¥ä¿®çŠ¶æ…‹ã®ã‚¹ã‚­ãƒ¼ãƒå®šç¾© ===
const BaseEnrollmentSchema = z.object({
  studentId: StudentIdSchema,
  courseId: CourseIdSchema,
  semester: SemesterSchema,
  version: z.number().int().positive()
});

export const RequestedEnrollmentSchema = BaseEnrollmentSchema.extend({
  status: z.literal('requested'),
  requestedAt: z.date()
});

export const ApprovedEnrollmentSchema = BaseEnrollmentSchema.extend({
  status: z.literal('approved'),
  requestedAt: z.date(),
  approvedAt: z.date(),
  approvedBy: z.string().min(1)
});

export const CancelledEnrollmentSchema = BaseEnrollmentSchema.extend({
  status: z.literal('cancelled'),
  requestedAt: z.date(),
  cancelledAt: z.date(),
  reason: z.string().min(1),
  approvedAt: z.date().optional(),
  approvedBy: z.string().optional()
});

export const CompletedEnrollmentSchema = BaseEnrollmentSchema.extend({
  status: z.literal('completed'),
  requestedAt: z.date(),
  approvedAt: z.date(),
  approvedBy: z.string().min(1),
  completedAt: z.date()
});

export const FailedEnrollmentSchema = BaseEnrollmentSchema.extend({
  status: z.literal('failed'),
  requestedAt: z.date(),
  approvedAt: z.date(),
  approvedBy: z.string().min(1),
  failedAt: z.date()
});

// === Discriminated Union ===
export const EnrollmentSchema = z.discriminatedUnion('status', [
  RequestedEnrollmentSchema,
  ApprovedEnrollmentSchema,
  CancelledEnrollmentSchema,
  CompletedEnrollmentSchema,
  FailedEnrollmentSchema
]);

export type RequestedEnrollment = z.infer<typeof RequestedEnrollmentSchema>;
export type ApprovedEnrollment = z.infer<typeof ApprovedEnrollmentSchema>;
export type CancelledEnrollment = z.infer<typeof CancelledEnrollmentSchema>;
export type CompletedEnrollment = z.infer<typeof CompletedEnrollmentSchema>;
export type FailedEnrollment = z.infer<typeof FailedEnrollmentSchema>;
export type Enrollment = z.infer<typeof EnrollmentSchema>;

// === å‹ã‚¬ãƒ¼ãƒ‰ ===
export const isRequested = (e: Enrollment): e is RequestedEnrollment => e.status === 'requested';
export const isApproved = (e: Enrollment): e is ApprovedEnrollment => e.status === 'approved';
export const isCancelled = (e: Enrollment): e is CancelledEnrollment => e.status === 'cancelled';
export const isCompleted = (e: Enrollment): e is CompletedEnrollment => e.status === 'completed';
export const isFailed = (e: Enrollment): e is FailedEnrollment => e.status === 'failed';

// === ãƒ•ã‚¡ã‚¯ãƒˆãƒªé–¢æ•° ===
export const createRequestedEnrollment = (
  studentId: StudentId,
  courseId: CourseId,
  semester: Semester
): RequestedEnrollment => RequestedEnrollmentSchema.parse({
  studentId,
  courseId,
  semester,
  status: 'requested',
  version: 1,
  requestedAt: new Date()
});

export const createApprovedEnrollment = (
  enrollment: RequestedEnrollment,
  approvedBy: string
): ApprovedEnrollment => ApprovedEnrollmentSchema.parse({
  ...enrollment,
  status: 'approved',
  approvedAt: new Date(),
  approvedBy,
  version: enrollment.version + 1
});

export const createCancelledFromRequested = (
  enrollment: RequestedEnrollment,
  reason: string
): CancelledEnrollment => CancelledEnrollmentSchema.parse({
  ...enrollment,
  status: 'cancelled',
  cancelledAt: new Date(),
  reason,
  version: enrollment.version + 1
});

export const createCancelledFromApproved = (
  enrollment: ApprovedEnrollment,
  reason: string
): CancelledEnrollment => CancelledEnrollmentSchema.parse({
  ...enrollment,
  status: 'cancelled',
  cancelledAt: new Date(),
  reason,
  version: enrollment.version + 1
});

export const createCompletedEnrollment = (
  enrollment: ApprovedEnrollment
): CompletedEnrollment => CompletedEnrollmentSchema.parse({
  ...enrollment,
  status: 'completed',
  completedAt: new Date(),
  version: enrollment.version + 1
});

export const createFailedEnrollment = (
  enrollment: ApprovedEnrollment
): FailedEnrollment => FailedEnrollmentSchema.parse({
  ...enrollment,
  status: 'failed',
  failedAt: new Date(),
  version: enrollment.version + 1
});
```

#### domain/errors.ts - ã‚¨ãƒ©ãƒ¼å®šç¾©

```typescript
import { z } from 'zod';

// === ã‚¨ãƒ©ãƒ¼ã‚¹ã‚­ãƒ¼ãƒ ===
const DomainErrorBase = z.object({
  type: z.string(),
  message: z.string(),
  code: z.string(),
  details: z.record(z.unknown()).optional()
});

export const ValidationErrorSchema = DomainErrorBase.extend({
  type: z.literal('ValidationError'),
  field: z.string().optional()
});

export const BusinessRuleErrorSchema = DomainErrorBase.extend({
  type: z.literal('BusinessRuleError'),
  rule: z.string()
});

export const NotFoundErrorSchema = DomainErrorBase.extend({
  type: z.literal('NotFoundError'),
  entity: z.string(),
  id: z.string()
});

export const ConcurrencyErrorSchema = DomainErrorBase.extend({
  type: z.literal('ConcurrencyError'),
  expectedVersion: z.number(),
  actualVersion: z.number(),
  conflictDetails: z.object({
    studentId: z.string(),
    courseId: z.string(),
    attemptedAt: z.date(),
    retryRecommended: z.boolean()
  })
});

export const StateTransitionErrorSchema = DomainErrorBase.extend({
  type: z.literal('StateTransitionError'),
  fromStatus: z.string(),
  toStatus: z.string(),
  allowedTransitions: z.array(z.string())
});

export const EnrollmentErrorSchema = z.discriminatedUnion('type', [
  ValidationErrorSchema,
  BusinessRuleErrorSchema,
  NotFoundErrorSchema,
  ConcurrencyErrorSchema,
  StateTransitionErrorSchema
]);

export type EnrollmentError = z.infer<typeof EnrollmentErrorSchema>;

// === ã‚¨ãƒ©ãƒ¼ãƒ•ã‚¡ã‚¯ãƒˆãƒªï¼ˆç°¡æ½”ç‰ˆï¼‰ ===
export const createValidationError = (
  message: string,
  code = 'VALIDATION_FAILED',
  field?: string
): z.infer<typeof ValidationErrorSchema> => ({
  type: 'ValidationError',
  message,
  code,
  field
});

export const createBusinessRuleError = (
  rule: string,
  message: string,
  code: string
): z.infer<typeof BusinessRuleErrorSchema> => ({
  type: 'BusinessRuleError',
  message,
  code,
  rule
});

export const createNotFoundError = (
  entity: string,
  id: string
): z.infer<typeof NotFoundErrorSchema> => ({
  type: 'NotFoundError',
  message: `${entity} with id ${id} not found`,
  code: 'NOT_FOUND',
  entity,
  id
});

export const createConcurrencyError = (
  expectedVersion: number,
  actualVersion: number,
  studentId: string,
  courseId: string
): z.infer<typeof ConcurrencyErrorSchema> => ({
  type: 'ConcurrencyError',
  message: `æ¥½è¦³çš„ãƒ­ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼: æœŸå¾…${expectedVersion}, å®Ÿéš›${actualVersion}`,
  code: 'CONCURRENCY_ERROR',
  expectedVersion,
  actualVersion,
  conflictDetails: {
    studentId,
    courseId,
    attemptedAt: new Date(),
    retryRecommended: Math.abs(actualVersion - expectedVersion) === 1
  }
});

export const createStateTransitionError = (
  fromStatus: string,
  toStatus: string,
  allowedTransitions: string[]
): z.infer<typeof StateTransitionErrorSchema> => ({
  type: 'StateTransitionError',
  message: `ä¸æ­£ãªçŠ¶æ…‹é·ç§»: ${fromStatus} â†’ ${toStatus}`,
  code: 'INVALID_STATE_TRANSITION',
  fromStatus,
  toStatus,
  allowedTransitions
});
```

#### domain/domain-events.ts - ã‚¤ãƒ™ãƒ³ãƒˆå®šç¾©

```typescript
import { z } from 'zod';
import { StudentIdSchema, CourseIdSchema, SemesterSchema } from './types';

// === ã‚¤ãƒ™ãƒ³ãƒˆã‚¹ã‚­ãƒ¼ãƒ ===
const DomainEventBase = z.object({
  studentId: StudentIdSchema,
  courseId: CourseIdSchema,
  eventType: z.string(),
  occurredAt: z.date(),
  version: z.number().int().positive()
});

export const EnrollmentRequestedEventSchema = DomainEventBase.extend({
  eventType: z.literal('EnrollmentRequested'),
  semester: SemesterSchema,
  requestedAt: z.date()
});

export const EnrollmentApprovedEventSchema = DomainEventBase.extend({
  eventType: z.literal('EnrollmentApproved'),
  approvedAt: z.date(),
  approvedBy: z.string().min(1)
});

export const EnrollmentCancelledEventSchema = DomainEventBase.extend({
  eventType: z.literal('EnrollmentCancelled'),
  cancelledAt: z.date(),
  reason: z.string().min(1),
  wasApproved: z.boolean()
});

export const EnrollmentCompletedEventSchema = DomainEventBase.extend({
  eventType: z.literal('EnrollmentCompleted'),
  completedAt: z.date()
});

export const EnrollmentFailedEventSchema = DomainEventBase.extend({
  eventType: z.literal('EnrollmentFailed'),
  failedAt: z.date()
});

export const EnrollmentDomainEventSchema = z.discriminatedUnion('eventType', [
  EnrollmentRequestedEventSchema,
  EnrollmentApprovedEventSchema,
  EnrollmentCancelledEventSchema,
  EnrollmentCompletedEventSchema,
  EnrollmentFailedEventSchema
]);

export type EnrollmentDomainEvent = z.infer<typeof EnrollmentDomainEventSchema>;

// === ã‚¤ãƒ™ãƒ³ãƒˆãƒ•ã‚¡ã‚¯ãƒˆãƒªï¼ˆç°¡æ½”ç‰ˆï¼‰ ===
export const createEnrollmentRequestedEvent = (
  studentId: z.infer<typeof StudentIdSchema>,
  courseId: z.infer<typeof CourseIdSchema>,
  semester: z.infer<typeof SemesterSchema>,
  version = 1
): z.infer<typeof EnrollmentRequestedEventSchema> => ({
  studentId,
  courseId,
  eventType: 'EnrollmentRequested',
  semester,
  requestedAt: new Date(),
  occurredAt: new Date(),
  version
});

export const createEnrollmentApprovedEvent = (
  studentId: z.infer<typeof StudentIdSchema>,
  courseId: z.infer<typeof CourseIdSchema>,
  approvedBy: string,
  version: number
): z.infer<typeof EnrollmentApprovedEventSchema> => ({
  studentId,
  courseId,
  eventType: 'EnrollmentApproved',
  approvedAt: new Date(),
  approvedBy,
  occurredAt: new Date(),
  version
});

export const createEnrollmentCancelledEvent = (
  studentId: z.infer<typeof StudentIdSchema>,
  courseId: z.infer<typeof CourseIdSchema>,
  reason: string,
  wasApproved: boolean,
  version: number
): z.infer<typeof EnrollmentCancelledEventSchema> => ({
  studentId,
  courseId,
  eventType: 'EnrollmentCancelled',
  cancelledAt: new Date(),
  reason,
  wasApproved,
  occurredAt: new Date(),
  version
});

export const createEnrollmentCompletedEvent = (
  studentId: z.infer<typeof StudentIdSchema>,
  courseId: z.infer<typeof CourseIdSchema>,
  version: number
): z.infer<typeof EnrollmentCompletedEventSchema> => ({
  studentId,
  courseId,
  eventType: 'EnrollmentCompleted',
  completedAt: new Date(),
  occurredAt: new Date(),
  version
});

export const createEnrollmentFailedEvent = (
  studentId: z.infer<typeof StudentIdSchema>,
  courseId: z.infer<typeof CourseIdSchema>,
  version: number
): z.infer<typeof EnrollmentFailedEventSchema> => ({
  studentId,
  courseId,
  eventType: 'EnrollmentFailed',
  failedAt: new Date(),
  occurredAt: new Date(),
  version
});
```

#### domain/enrollment-aggregate.ts - é›†ç´„æ“ä½œ

```typescript
import {
  Either, left, right, StudentId, CourseId, Semester,
  Enrollment, RequestedEnrollment, ApprovedEnrollment,
  createRequestedEnrollment, createApprovedEnrollment,
  createCancelledFromRequested, createCancelledFromApproved,
  createCompletedEnrollment, createFailedEnrollment,
  isRequested, isApproved
} from './types';
import {
  EnrollmentDomainEvent,
  createEnrollmentRequestedEvent,
  createEnrollmentApprovedEvent,
  createEnrollmentCancelledEvent,
  createEnrollmentCompletedEvent,
  createEnrollmentFailedEvent
} from './domain-events';
import {
  EnrollmentError, createValidationError,
  createConcurrencyError, createStateTransitionError
} from './errors';

// === çŠ¶æ…‹é·ç§»é–¢æ•° ===
export const requestEnrollment = (
  studentId: StudentId,
  courseId: CourseId,
  semester: Semester
): Either<EnrollmentError, RequestedEnrollment & { domainEvent: EnrollmentDomainEvent }> => {
  const enrollment = createRequestedEnrollment(studentId, courseId, semester);
  const event = createEnrollmentRequestedEvent(studentId, courseId, semester, 1);
  return right({ ...enrollment, domainEvent: event });
};

export const approveEnrollment = (
  enrollment: RequestedEnrollment,
  approvedBy: string
): Either<EnrollmentError, ApprovedEnrollment & { domainEvent: EnrollmentDomainEvent }> => {
  const updated = createApprovedEnrollment(enrollment, approvedBy);
  const event = createEnrollmentApprovedEvent(
    enrollment.studentId,
    enrollment.courseId,
    approvedBy,
    updated.version
  );
  return right({ ...updated, domainEvent: event });
};

export const cancelRequestedEnrollment = (
  enrollment: RequestedEnrollment,
  reason: string
): Either<EnrollmentError, z.infer<typeof CancelledEnrollmentSchema> & { domainEvent: EnrollmentDomainEvent }> => {
  const updated = createCancelledFromRequested(enrollment, reason);
  const event = createEnrollmentCancelledEvent(
    enrollment.studentId,
    enrollment.courseId,
    reason,
    false,
    updated.version
  );
  return right({ ...updated, domainEvent: event });
};

export const cancelApprovedEnrollment = (
  enrollment: ApprovedEnrollment,
  reason: string
): Either<EnrollmentError, z.infer<typeof CancelledEnrollmentSchema> & { domainEvent: EnrollmentDomainEvent }> => {
  const updated = createCancelledFromApproved(enrollment, reason);
  const event = createEnrollmentCancelledEvent(
    enrollment.studentId,
    enrollment.courseId,
    reason,
    true,
    updated.version
  );
  return right({ ...updated, domainEvent: event });
};

export const completeEnrollment = (
  enrollment: ApprovedEnrollment
): Either<EnrollmentError, z.infer<typeof CompletedEnrollmentSchema> & { domainEvent: EnrollmentDomainEvent }> => {
  const updated = createCompletedEnrollment(enrollment);
  const event = createEnrollmentCompletedEvent(
    enrollment.studentId,
    enrollment.courseId,
    updated.version
  );
  return right({ ...updated, domainEvent: event });
};

export const failEnrollment = (
  enrollment: ApprovedEnrollment
): Either<EnrollmentError, z.infer<typeof FailedEnrollmentSchema> & { domainEvent: EnrollmentDomainEvent }> => {
  const updated = createFailedEnrollment(enrollment);
  const event = createEnrollmentFailedEvent(
    enrollment.studentId,
    enrollment.courseId,
    updated.version
  );
  return right({ ...updated, domainEvent: event });
};

// === å‹å®‰å…¨ãªãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ãƒƒã‚¯æ“ä½œ ===
export const safeCancelEnrollment = (
  enrollment: Enrollment,
  reason: string
): Either<EnrollmentError, any> => {
  if (isRequested(enrollment)) return cancelRequestedEnrollment(enrollment, reason);
  if (isApproved(enrollment)) return cancelApprovedEnrollment(enrollment, reason);

  return left(createStateTransitionError(
    enrollment.status,
    'cancelled',
    ['requested', 'approved']
  ));
};

export const safeApproveEnrollment = (
  enrollment: Enrollment,
  approvedBy: string
): Either<EnrollmentError, any> => {
  if (!isRequested(enrollment)) {
    return left(createStateTransitionError(
      enrollment.status,
      'approved',
      ['requested']
    ));
  }
  return approveEnrollment(enrollment, approvedBy);
};

export const safeCompleteEnrollment = (
  enrollment: Enrollment
): Either<EnrollmentError, any> => {
  if (!isApproved(enrollment)) {
    return left(createStateTransitionError(
      enrollment.status,
      'completed',
      ['approved']
    ));
  }
  return completeEnrollment(enrollment);
};

export const safeFailEnrollment = (
  enrollment: Enrollment
): Either<EnrollmentError, any> => {
  if (!isApproved(enrollment)) {
    return left(createStateTransitionError(
      enrollment.status,
      'failed',
      ['approved']
    ));
  }
  return failEnrollment(enrollment);
};

// === ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãƒã‚§ãƒƒã‚¯ ===
export const updateWithVersionCheck = <T extends Enrollment>(
  currentEnrollment: T,
  expectedVersion: number,
  updateFn: (enrollment: T) => Either<EnrollmentError, any>
): Either<EnrollmentError, any> => {
  if (currentEnrollment.version !== expectedVersion) {
    return left(createConcurrencyError(
      expectedVersion,
      currentEnrollment.version,
      currentEnrollment.studentId,
      currentEnrollment.courseId
    ));
  }
  return updateFn(currentEnrollment);
};

// === ã‚¤ãƒ™ãƒ³ãƒˆã‹ã‚‰ã®å¾©å…ƒ ===
export const reconstructEnrollmentFromEvents = (
  events: EnrollmentDomainEvent[]
): Either<EnrollmentError, Enrollment | null> => {
  if (events.length === 0) return right(null);

  const sortedEvents = events.sort((a, b) => a.version - b.version);
  const firstEvent = sortedEvents[0];

  if (firstEvent.eventType !== 'EnrollmentRequested') {
    return left(createValidationError(
      'æœ€åˆã®ã‚¤ãƒ™ãƒ³ãƒˆã¯EnrollmentRequestedEventã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™',
      'INVALID_EVENT_STREAM'
    ));
  }

  let enrollment: Enrollment = createRequestedEnrollment(
    firstEvent.studentId,
    firstEvent.courseId,
    firstEvent.semester
  );

  for (let i = 1; i < sortedEvents.length; i++) {
    const event = sortedEvents[i];

    switch (event.eventType) {
      case 'EnrollmentApproved':
        if (!isRequested(enrollment)) {
          return left(createValidationError(
            `ApprovedEventã‚’é©ç”¨ã§ãã¾ã›ã‚“ã€‚ç¾åœ¨ã®çŠ¶æ…‹: ${enrollment.status}`,
            'INVALID_EVENT_APPLICATION'
          ));
        }
        enrollment = createApprovedEnrollment(enrollment, event.approvedBy);
        enrollment = { ...enrollment, version: event.version };
        break;

      case 'EnrollmentCancelled':
        if (isRequested(enrollment)) {
          enrollment = createCancelledFromRequested(enrollment, event.reason);
        } else if (isApproved(enrollment)) {
          enrollment = createCancelledFromApproved(enrollment, event.reason);
        } else {
          return left(createValidationError(
            `CancelledEventã‚’é©ç”¨ã§ãã¾ã›ã‚“ã€‚ç¾åœ¨ã®çŠ¶æ…‹: ${enrollment.status}`,
            'INVALID_EVENT_APPLICATION'
          ));
        }
        enrollment = { ...enrollment, version: event.version };
        break;

      case 'EnrollmentCompleted':
        if (!isApproved(enrollment)) {
          return left(createValidationError(
            `CompletedEventã‚’é©ç”¨ã§ãã¾ã›ã‚“ã€‚ç¾åœ¨ã®çŠ¶æ…‹: ${enrollment.status}`,
            'INVALID_EVENT_APPLICATION'
          ));
        }
        enrollment = createCompletedEnrollment(enrollment);
        enrollment = { ...enrollment, version: event.version };
        break;

      case 'EnrollmentFailed':
        if (!isApproved(enrollment)) {
          return left(createValidationError(
            `FailedEventã‚’é©ç”¨ã§ãã¾ã›ã‚“ã€‚ç¾åœ¨ã®çŠ¶æ…‹: ${enrollment.status}`,
            'INVALID_EVENT_APPLICATION'
          ));
        }
        enrollment = createFailedEnrollment(enrollment);
        enrollment = { ...enrollment, version: event.version };
        break;

      default:
        return left(createValidationError(
          `æœªçŸ¥ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚¿ã‚¤ãƒ—: ${event.eventType}`,
          'UNKNOWN_EVENT_TYPE'
        ));
    }
  }

  return right(enrollment);
};

// å¿…è¦ãªã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚’è¿½åŠ 
import { CancelledEnrollmentSchema, CompletedEnrollmentSchema, FailedEnrollmentSchema } from './types';
import { z } from 'zod';
```

### 2. ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å±¤

#### application/ports.ts - ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹å®šç¾©

```typescript
import { Either } from '../domain/types';
import { Enrollment, StudentId, CourseId } from '../domain/types';
import { EnrollmentDomainEvent } from '../domain/domain-events';
import { EnrollmentError } from '../domain/errors';

// === ãƒªãƒã‚¸ãƒˆãƒªã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ ===
export interface IEnrollmentRepository {
  findByStudentAndCourse(
    studentId: StudentId,
    courseId: CourseId
  ): Promise<Either<EnrollmentError, Enrollment | null>>;

  findByStudent(
    studentId: StudentId
  ): Promise<Either<EnrollmentError, Enrollment[]>>;

  getEventHistory(
    studentId: StudentId,
    courseId: CourseId
  ): Promise<Either<EnrollmentError, EnrollmentDomainEvent[]>>;

  save(
    enrollment: Enrollment,
    event: EnrollmentDomainEvent
  ): Promise<Either<EnrollmentError, void>>;

  withTransaction<T>(
    fn: (tx: ITransactionContext) => Promise<T>
  ): Promise<T>;
}

export interface ITransactionContext {
  findByStudentAndCourseForUpdate(
    studentId: StudentId,
    courseId: CourseId
  ): Promise<Either<EnrollmentError, Enrollment | null>>;

  save(
    enrollment: Enrollment,
    event: EnrollmentDomainEvent
  ): Promise<Either<EnrollmentError, void>>;
}

// === å¤–éƒ¨ã‚·ã‚¹ãƒ†ãƒ ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ ===
export interface IStudentSystemAdapter {
  validateStudent(studentId: StudentId): Promise<Either<EnrollmentError, StudentInfo>>;
  checkPrerequisites(
    studentId: StudentId,
    courseId: CourseId
  ): Promise<Either<EnrollmentError, PrerequisiteCheckResult>>;
  checkGPARequirement(
    studentId: StudentId,
    minGPA: number
  ): Promise<Either<EnrollmentError, boolean>>;
}

export interface ICourseSystemAdapter {
  getCourseInfo(courseId: CourseId): Promise<Either<EnrollmentError, CourseInfo>>;
  checkCapacity(courseId: CourseId): Promise<Either<EnrollmentError, CapacityCheckResult>>;
  checkScheduleConflict(
    studentId: StudentId,
    courseId: CourseId
  ): Promise<Either<EnrollmentError, boolean>>;
}

export interface INotificationService {
  notifyEnrollmentRequested(studentId: StudentId, courseId: CourseId): Promise<void>;
  notifyEnrollmentApproved(
    studentId: StudentId,
    courseId: CourseId,
    approvedBy: string
  ): Promise<void>;
  notifyEnrollmentCancelled(
    studentId: StudentId,
    courseId: CourseId,
    reason: string
  ): Promise<void>;
}

// === DTOs ===
export interface StudentInfo {
  readonly studentId: StudentId;
  readonly name: string;
  readonly department: string;
  readonly year: number;
  readonly gpa: number;
  readonly isActive: boolean;
}

export interface CourseInfo {
  readonly courseId: CourseId;
  readonly name: string;
  readonly credits: number;
  readonly instructor: string;
  readonly capacity: number;
  readonly enrolled: number;
  readonly minGPA?: number;
  readonly prerequisites: CourseId[];
}

export interface PrerequisiteCheckResult {
  readonly satisfied: boolean;
  readonly missing: CourseId[];
}

export interface CapacityCheckResult {
  readonly available: boolean;
  readonly capacity: number;
  readonly enrolled: number;
  readonly waitlistAvailable: boolean;
}
```

#### application/dtos.ts - DTOså®šç¾©

```typescript
import { Enrollment } from '../domain/types';

// === ã‚³ãƒãƒ³ãƒ‰ ===
export interface RequestEnrollmentCommand {
  readonly studentId: string;
  readonly courseId: string;
  readonly semester: string;
}

export interface ApproveEnrollmentCommand {
  readonly studentId: string;
  readonly courseId: string;
  readonly approvedBy: string;
}

export interface CancelEnrollmentCommand {
  readonly studentId: string;
  readonly courseId: string;
  readonly reason: string;
}

export interface CompleteEnrollmentCommand {
  readonly studentId: string;
  readonly courseId: string;
}

export interface FailEnrollmentCommand {
  readonly studentId: string;
  readonly courseId: string;
}

// === ãƒ¬ã‚¹ãƒãƒ³ã‚¹ ===
export interface EnrollmentDto {
  readonly studentId: string;
  readonly courseId: string;
  readonly semester: string;
  readonly status: string;
  readonly version: number;
  readonly requestedAt: string;
  readonly approvedAt?: string;
  readonly approvedBy?: string;
  readonly cancelledAt?: string;
  readonly reason?: string;
  readonly completedAt?: string;
  readonly failedAt?: string;
}

export interface EnrollmentListDto {
  readonly enrollments: EnrollmentDto[];
  readonly total: number;
}

// === ãƒãƒƒãƒ‘ãƒ¼ ===
export const toEnrollmentDto = (enrollment: Enrollment): EnrollmentDto => {
  const base = {
    studentId: enrollment.studentId,
    courseId: enrollment.courseId,
    semester: enrollment.semester,
    status: enrollment.status,
    version: enrollment.version,
    requestedAt: enrollment.requestedAt.toISOString()
  };

  switch (enrollment.status) {
    case 'requested':
      return base;
    case 'approved':
      return {
        ...base,
        approvedAt: enrollment.approvedAt.toISOString(),
        approvedBy: enrollment.approvedBy
      };
    case 'cancelled':
      return {
        ...base,
        cancelledAt: enrollment.cancelledAt.toISOString(),
        reason: enrollment.reason,
        approvedAt: enrollment.approvedAt?.toISOString(),
        approvedBy: enrollment.approvedBy
      };
    case 'completed':
      return {
        ...base,
        approvedAt: enrollment.approvedAt.toISOString(),
        approvedBy: enrollment.approvedBy,
        completedAt: enrollment.completedAt.toISOString()
      };
    case 'failed':
      return {
        ...base,
        approvedAt: enrollment.approvedAt.toISOString(),
        approvedBy: enrollment.approvedBy,
        failedAt: enrollment.failedAt.toISOString()
      };
  }
};
```

## ğŸš€ é–¢æ•°å‹ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã«ã‚ˆã‚‹éåŒæœŸå‡¦ç†

### application/fp-utils.ts - pipe é–¢æ•°ã¨åŸºæœ¬ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£

```typescript
// åŸºæœ¬çš„ãª pipe å®Ÿè£…
export const pipe = <T>(...fns: any[]): ((x: T) => any) => 
  (x: T) => fns.reduce((v, f) => f(v), x);

// ã‚ˆã‚Šå‹å®‰å…¨ãª pipeï¼ˆã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ç‰ˆï¼‰
export function pipe<A>(value: A): A;
export function pipe<A, B>(value: A, ab: (a: A) => B): B;
export function pipe<A, B, C>(value: A, ab: (a: A) => B, bc: (b: B) => C): C;
export function pipe<A, B, C, D>(
  value: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D
): D;
export function pipe<A, B, C, D, E>(
  value: A,
  ab: (a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D,
  de: (d: D) => E
): E;
export function pipe(value: any, ...fns: any[]): any {
  return fns.reduce((v, f) => f(v), value);
}

// flow: é–¢æ•°ã‚’åˆæˆã—ã¦æ–°ã—ã„é–¢æ•°ã‚’ä½œã‚‹
export const flow = <A extends readonly unknown[], B>(
  ab: (...a: A) => B
): ((...a: A) => B) => ab;

export function flow<A extends readonly unknown[], B, C>(
  ab: (...a: A) => B,
  bc: (b: B) => C
): (...a: A) => C;

export function flow<A extends readonly unknown[], B, C, D>(
  ab: (...a: A) => B,
  bc: (b: B) => C,
  cd: (c: C) => D
): (...a: A) => D;

export function flow(...fns: any[]): any {
  return (...args: any[]) => pipe(...args, ...fns);
}
```

### application/task-either.ts - éåŒæœŸEitherå‹

```typescript
export type TaskEither<E, A> = () => Promise<Either<E, A>>;

// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
export const taskOf = <E, A>(value: A): TaskEither<E, A> =>
  async () => right(value);

export const taskLeft = <E, A>(error: E): TaskEither<E, A> =>
  async () => left(error);

export const taskRight = <E, A>(value: A): TaskEither<E, A> =>
  async () => right(value);

// fromPromise: Promise<T> â†’ TaskEither<E, T>
export const fromPromise = <E, A>(
  promise: Promise<A>,
  onError: (error: unknown) => E
): TaskEither<E, A> =>
  async () => {
    try {
      const result = await promise;
      return right(result);
    } catch (error) {
      return left(onError(error));
    }
  };

// fromEither: Either<E, A> â†’ TaskEither<E, A>
export const fromEither = <E, A>(either: Either<E, A>): TaskEither<E, A> =>
  async () => either;

// map: (A â†’ B) â†’ TaskEither<E, A> â†’ TaskEither<E, B>
export const map = <E, A, B>(
  f: (a: A) => B
) => (task: TaskEither<E, A>): TaskEither<E, B> =>
  async () => {
    const result = await task();
    return result.type === 'left' ? result : right(f(result.value));
  };

// flatMap: (A â†’ TaskEither<E, B>) â†’ TaskEither<E, A> â†’ TaskEither<E, B>
export const flatMap = <E, A, B>(
  f: (a: A) => TaskEither<E, B>
) => (task: TaskEither<E, A>): TaskEither<E, B> =>
  async () => {
    const result = await task();
    if (result.type === 'left') return result;
    return f(result.value)();
  };

// parallel: TaskEither<E, A>[] â†’ TaskEither<E, A[]>
export const parallel = <E, A>(
  tasks: TaskEither<E, A>[]
): TaskEither<E, A[]> =>
  async () => {
    const promises = tasks.map(task => task());
    const results = await Promise.all(promises);
    
    const values: A[] = [];
    for (const result of results) {
      if (result.type === 'left') return result;
      values.push(result.value);
    }
    return right(values);
  };
```

### application/task-either-pipe.ts - pipeç”¨ã‚ªãƒšãƒ¬ãƒ¼ã‚¿

```typescript
import { TaskEither, map, flatMap, parallel } from './task-either';
import { pipe } from './fp-utils';

// TaskEither ç”¨ã® pipe ã‚ªãƒšãƒ¬ãƒ¼ã‚¿
export const TE = {
  // map: (A â†’ B) â†’ (TaskEither<E, A> â†’ TaskEither<E, B>)
  map: <E, A, B>(f: (a: A) => B) => (te: TaskEither<E, A>): TaskEither<E, B> =>
    map(f)(te),

  // flatMap: (A â†’ TaskEither<E, B>) â†’ (TaskEither<E, A> â†’ TaskEither<E, B>)
  flatMap: <E, A, B>(f: (a: A) => TaskEither<E, B>) => (te: TaskEither<E, A>): TaskEither<E, B> =>
    flatMap(f)(te),

  // tap: ãƒ‡ãƒãƒƒã‚°ç”¨ï¼ˆå€¤ã‚’å¤‰æ›´ã›ãšã«å‰¯ä½œç”¨ã®ã¿ï¼‰
  tap: <E, A>(f: (a: A) => void) => (te: TaskEither<E, A>): TaskEither<E, A> =>
    map((a: A) => { f(a); return a; })(te),

  // filter: æ¡ä»¶ã‚’æº€ãŸã•ãªã„å ´åˆã¯ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã™
  filter: <E, A>(predicate: (a: A) => boolean, onFalse: () => E) => 
    (te: TaskEither<E, A>): TaskEither<E, A> =>
      flatMap((a: A) => predicate(a) ? taskOf(a) : taskLeft(onFalse()))(te),

  // fold: Either ã®ä¸¡å´ã‚’å‡¦ç†
  fold: <E, A, B>(onLeft: (e: E) => B, onRight: (a: A) => B) => 
    (te: TaskEither<E, A>): Promise<B> =>
      te().then(either => 
        either.type === 'left' ? onLeft(either.value) : onRight(either.value)
      ),

  // getOrElse: ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’è¿”ã™
  getOrElse: <E, A>(onLeft: (e: E) => A) => (te: TaskEither<E, A>): Promise<A> =>
    te().then(either => 
      either.type === 'left' ? onLeft(either.value) : either.value
    )
};

// çµ„ã¿åˆã‚ã›ã‚ªãƒšãƒ¬ãƒ¼ã‚¿
export const combine = {
  // è¤‡æ•°ã® TaskEither ã‚’ä¸¦åˆ—å®Ÿè¡Œã—ã¦çµæœã‚’çµ„ã¿åˆã‚ã›
  parallel: <E, A, B, C>(
    f: (a: A, b: B) => C
  ) => (ta: TaskEither<E, A>, tb: TaskEither<E, B>): TaskEither<E, C> =>
    pipe(
      parallel([ta, tb]),
      TE.map(([a, b]) => f(a, b))
    ),

  // 3ã¤ã® TaskEither ã‚’ä¸¦åˆ—å®Ÿè¡Œ
  parallel3: <E, A, B, C, D>(
    f: (a: A, b: B, c: C) => D
  ) => (ta: TaskEither<E, A>, tb: TaskEither<E, B>, tc: TaskEither<E, C>): TaskEither<E, D> =>
    pipe(
      parallel([ta, tb, tc]),
      TE.map(([a, b, c]) => f(a, b, c))
    ),

  // æ¡ä»¶ä»˜ãå®Ÿè¡Œ
  when: <E, A>(condition: boolean, te: TaskEither<E, A>) => 
    (defaultValue: A): TaskEither<E, A> =>
      condition ? te : taskOf(defaultValue)
};
```

### application/middleware.ts - æ¨ªæ–­çš„é–¢å¿ƒäº‹

```typescript
import { pipe } from './fp-utils';
import { TE } from './task-either-pipe';

// æ¨ªæ–­çš„é–¢å¿ƒäº‹ã®ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢
export const middleware = {
  // ãƒ­ã‚°è¨˜éŒ²
  withLogging: <E, A>(context: string) => (te: TaskEither<E, A>): TaskEither<E, A> =>
    pipe(
      taskOf(Date.now()),
      TE.tap(() => console.log(`é–‹å§‹: ${context}`)),
      TE.flatMap((start) =>
        pipe(
          te,
          TE.tap((result) => {
            const duration = Date.now() - start;
            console.log(`æˆåŠŸ: ${context} (${duration}ms)`);
          })
        )
      )
    ),

  // ãƒªãƒˆãƒ©ã‚¤
  withRetry: <E, A>(maxAttempts: number, delay: number) => 
    (te: TaskEither<E, A>): TaskEither<E, A> => {
      const attempt = (remainingAttempts: number): TaskEither<E, A> =>
        remainingAttempts === 0
          ? te
          : pipe(
              te,
              TE.fold(
                (error) => 
                  remainingAttempts > 1
                    ? pipe(
                        fromPromise(
                          new Promise(resolve => setTimeout(resolve, delay)),
                          () => error
                        ),
                        TE.flatMap(() => attempt(remainingAttempts - 1))
                      )
                    : taskLeft(error),
                (value) => taskOf(value)
              ),
              (promise) => () => promise
            );
      
      return attempt(maxAttempts);
    },

  // ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³
  withTransaction: <E, A>(repo: IEnrollmentRepository) => 
    (te: (tx: ITransactionContext) => TaskEither<E, A>): TaskEither<E, A> =>
      fromPromise(
        repo.withTransaction(async (tx) => {
          const result = await te(tx)();
          if (result.type === 'left') {
            throw result.value;
          }
          return result.value;
        }),
        (error) => error as E
      )
};
```

#### application/enrollment-service-pipe.ts - pipe ã‚’ä½¿ã£ãŸé–¢æ•°å‹ã‚µãƒ¼ãƒ“ã‚¹

```typescript
import { pipe } from './fp-utils';
import { TE, combine } from './task-either-pipe';
import { 
  TaskEither, taskOf, taskLeft, fromPromise, fromEither 
} from './task-either';
import {
  Either, left, right,
  StudentIdSchema, CourseIdSchema, SemesterSchema
} from '../domain/types';
import {
  requestEnrollment, safeApproveEnrollment, safeCancelEnrollment,
  safeCompleteEnrollment, safeFailEnrollment, reconstructEnrollmentFromEvents
} from '../domain/enrollment-aggregate';
import {
  EnrollmentError, createValidationError, createBusinessRuleError,
  createNotFoundError
} from '../domain/errors';
import {
  IEnrollmentRepository, IStudentSystemAdapter, ICourseSystemAdapter,
  INotificationService
} from './ports';
import {
  RequestEnrollmentCommand, ApproveEnrollmentCommand, CancelEnrollmentCommand,
  CompleteEnrollmentCommand, FailEnrollmentCommand,
  EnrollmentDto, EnrollmentListDto, toEnrollmentDto
} from './dtos';

// ä¾å­˜é–¢ä¿‚æ³¨å…¥å‹
type EnrollmentDeps = {
  readonly repo: IEnrollmentRepository;
  readonly studentSystem: IStudentSystemAdapter;
  readonly courseSystem: ICourseSystemAdapter;
  readonly notification: INotificationService;
};

// å…¥åŠ›æ¤œè¨¼
const validateInput = (command: RequestEnrollmentCommand): TaskEither<EnrollmentError, ValidatedInput> =>
  pipe(
    command,
    (cmd) => {
      const studentId = StudentIdSchema.safeParse(cmd.studentId);
      const courseId = CourseIdSchema.safeParse(cmd.courseId);
      const semester = SemesterSchema.safeParse(cmd.semester);

      return !studentId.success || !courseId.success || !semester.success
        ? taskLeft(createValidationError('ç„¡åŠ¹ãªå…¥åŠ›ã§ã™'))
        : taskOf({
            studentId: studentId.data,
            courseId: courseId.data,
            semester: semester.data
          });
    }
  );

// æ—¢å­˜å±¥ä¿®ãƒã‚§ãƒƒã‚¯
const checkExisting = (deps: EnrollmentDeps) => (input: ValidatedInput): TaskEither<EnrollmentError, ValidatedInput> =>
  pipe(
    fromPromise(
      deps.repo.findByStudentAndCourse(input.studentId, input.courseId),
      (error) => error as EnrollmentError
    ),
    TE.flatMap((result) =>
      result.type === 'left' 
        ? taskLeft(result.value)
        : result.value !== null
          ? taskLeft(createBusinessRuleError('DUPLICATE_ENROLLMENT', 'æ—¢ã«å±¥ä¿®ç”³è«‹ã•ã‚Œã¦ã„ã¾ã™', 'ENROLLMENT_EXISTS'))
          : taskOf(input)
    )
  );

// å­¦ç”Ÿãƒ»ç§‘ç›®æƒ…å ±ã®å–å¾—ï¼ˆä¸¦åˆ—ï¼‰
const fetchStudentAndCourse = (deps: EnrollmentDeps) => (input: ValidatedInput) =>
  combine.parallel(
    (student: StudentInfo, course: CourseInfo) => ({ student, course, input })
  )(
    fromPromise(
      deps.studentSystem.validateStudent(input.studentId).then(r => 
        r.type === 'left' ? Promise.reject(r.value) : Promise.resolve(r.value)
      ),
      (error) => error as EnrollmentError
    ),
    fromPromise(
      deps.courseSystem.getCourseInfo(input.courseId).then(r => 
        r.type === 'left' ? Promise.reject(r.value) : Promise.resolve(r.value)
      ),
      (error) => error as EnrollmentError
    )
  );

// ãƒ“ã‚¸ãƒã‚¹ãƒ«ãƒ¼ãƒ«ãƒã‚§ãƒƒã‚¯ï¼ˆä¸¦åˆ—ï¼‰
const checkBusinessRules = (deps: EnrollmentDeps) => 
  (data: { student: StudentInfo; course: CourseInfo; input: ValidatedInput }) =>
    pipe(
      combine.parallel3(
        (prereq: PrerequisiteCheckResult, capacity: CapacityCheckResult, gpa: boolean) => ({
          ...data,
          checks: { prereq, capacity, gpa, conflict: false }
        })
      )(
        fromPromise(
          deps.studentSystem.checkPrerequisites(data.input.studentId, data.input.courseId).then(r => 
            r.type === 'left' ? Promise.reject(r.value) : Promise.resolve(r.value)
          ),
          (error) => error as EnrollmentError
        ),
        fromPromise(
          deps.courseSystem.checkCapacity(data.input.courseId).then(r => 
            r.type === 'left' ? Promise.reject(r.value) : Promise.resolve(r.value)
          ),
          (error) => error as EnrollmentError
        ),
        data.course.minGPA
          ? fromPromise(
              deps.studentSystem.checkGPARequirement(data.input.studentId, data.course.minGPA).then(r => 
                r.type === 'left' ? Promise.reject(r.value) : Promise.resolve(r.value)
              ),
              (error) => error as EnrollmentError
            )
          : taskOf(true)
      ),
      TE.flatMap((result) =>
        // ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ç«¶åˆãƒã‚§ãƒƒã‚¯ã‚’è¿½åŠ 
        pipe(
          fromPromise(
            deps.courseSystem.checkScheduleConflict(data.input.studentId, data.input.courseId).then(r => 
              r.type === 'left' ? Promise.reject(r.value) : Promise.resolve(r.value)
            ),
            (error) => error as EnrollmentError
          ),
          TE.map(conflict => ({
            ...result,
            checks: { ...result.checks, conflict }
          }))
        )
      )
    );

// ãƒ“ã‚¸ãƒã‚¹ãƒ«ãƒ¼ãƒ«é•åã®æ¤œè¨¼
const validateConstraints = (data: any): TaskEither<EnrollmentError, any> =>
  pipe(
    data,
    (d) => {
      if (!d.checks.prereq.satisfied) {
        return taskLeft(createBusinessRuleError(
          'PREREQUISITES_NOT_MET',
          `å‰æç§‘ç›®ãŒä¸è¶³: ${d.checks.prereq.missing.join(', ')}`,
          'MISSING_PREREQUISITES'
        ));
      }

      if (!d.checks.capacity.available) {
        return taskLeft(createBusinessRuleError(
          'COURSE_FULL',
          'å®šå“¡ã«é”ã—ã¦ã„ã¾ã™',
          'NO_CAPACITY'
        ));
      }

      if (!d.checks.gpa) {
        return taskLeft(createBusinessRuleError(
          'GPA_REQUIREMENT_NOT_MET',
          `GPAè¦ä»¶æœªé”ï¼ˆå¿…è¦: ${d.course.minGPA}ï¼‰`,
          'LOW_GPA'
        ));
      }

      if (d.checks.conflict) {
        return taskLeft(createBusinessRuleError(
          'SCHEDULE_CONFLICT',
          'å—è¬›æ™‚é–“ãŒé‡è¤‡ã—ã¦ã„ã¾ã™',
          'TIME_CONFLICT'
        ));
      }

      return taskOf(d);
    }
  );

// å±¥ä¿®ç”³è«‹ä½œæˆ
const createRequest = (data: any): TaskEither<EnrollmentError, any> =>
  pipe(
    fromEither(requestEnrollment(data.input.studentId, data.input.courseId, data.input.semester)),
    TE.map(enrollmentWithEvent => ({ ...data, enrollmentWithEvent }))
  );

// æ°¸ç¶šåŒ–
const persistEnrollment = (deps: EnrollmentDeps) => (data: any): TaskEither<EnrollmentError, any> =>
  pipe(
    data.enrollmentWithEvent,
    (ewe) => {
      const { domainEvent, ...enrollment } = ewe;
      return pipe(
        fromPromise(
          deps.repo.save(enrollment, domainEvent).then(result => 
            result.type === 'left' ? Promise.reject(result.value) : Promise.resolve(result.value)
          ),
          (error) => error as EnrollmentError
        ),
        TE.map(() => ({ ...data, enrollment }))
      );
    }
  );

// é€šçŸ¥é€ä¿¡ï¼ˆå‰¯ä½œç”¨ï¼‰
const sendNotification = (deps: EnrollmentDeps) => (data: any): TaskEither<EnrollmentError, Enrollment> =>
  pipe(
    taskOf(data.enrollment),
    TE.tap((enrollment) => {
      // éåŒæœŸã§é€šçŸ¥é€ä¿¡ï¼ˆã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–ï¼‰
      deps.notification
        .notifyEnrollmentRequested(enrollment.studentId, enrollment.courseId)
        .catch(err => console.error('é€šçŸ¥é€ä¿¡ã‚¨ãƒ©ãƒ¼:', err));
    })
  );

// DTOã¸ã®å¤‰æ›
const toDto = (enrollment: Enrollment): TaskEither<EnrollmentError, EnrollmentDto> =>
  taskOf(toEnrollmentDto(enrollment));

// ãƒ¡ã‚¤ãƒ³é–¢æ•°ï¼špipe ã‚’ä½¿ã£ãŸå®Ÿè£…
export const requestEnrollmentWithPipe = (deps: EnrollmentDeps) => 
  (command: RequestEnrollmentCommand): TaskEither<EnrollmentError, EnrollmentDto> =>
    pipe(
      validateInput(command),
      TE.flatMap(checkExisting(deps)),
      TE.flatMap(fetchStudentAndCourse(deps)),
      TE.flatMap(checkBusinessRules(deps)),
      TE.flatMap(validateConstraints),
      TE.flatMap(createRequest),
      TE.flatMap(persistEnrollment(deps)),
      TE.flatMap(sendNotification(deps)),
      TE.flatMap(toDto)
    );

// ä½¿ç”¨ä¾‹
export class FunctionalEnrollmentService {
  constructor(private readonly deps: EnrollmentDeps) {}

  async requestEnrollment(command: RequestEnrollmentCommand): Promise<Either<EnrollmentError, EnrollmentDto>> {
    return pipe(
      command,
      requestEnrollmentWithPipe(this.deps),
      middleware.withLogging('å±¥ä¿®ç”³è«‹å‡¦ç†'),
      middleware.withRetry(3, 1000),
      middleware.withTransaction(this.deps.repo)
    )();
  }
}

### ğŸ¯ pipe ã‚’ä½¿ã£ãŸè¨­è¨ˆã®åˆ©ç‚¹

1. **å¯èª­æ€§**: ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼ãŒä¸Šã‹ã‚‰ä¸‹ã«èª­ã¿ã‚„ã™ã„
2. **åˆæˆå¯èƒ½æ€§**: å°ã•ãªé–¢æ•°ã‚’çµ„ã¿åˆã‚ã›ã¦è¤‡é›‘ãªå‡¦ç†ã‚’æ§‹ç¯‰
3. **ãƒ†ã‚¹ã‚¿ãƒ–ãƒ«**: å„ã‚¹ãƒ†ãƒƒãƒ—ã‚’ç‹¬ç«‹ã—ã¦ãƒ†ã‚¹ãƒˆå¯èƒ½
4. **å†åˆ©ç”¨æ€§**: ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã‚„é–¢æ•°ã‚’ä»–ã®å‡¦ç†ã§ã‚‚ä½¿ã„å›ã—å¯èƒ½
5. **å‹å®‰å…¨æ€§**: TypeScript ã®å‹æ¨è«–ãŒåŠ¹æœçš„ã«åƒã
6. **ãƒ‡ãƒãƒƒã‚°å®¹æ˜“æ€§**: pipe ã®å„æ®µéšã§å€¤ã‚’ç¢ºèªå¯èƒ½

### ğŸ“ ä½¿ç”¨ä¾‹ã¨ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰

```typescript
// ä½¿ç”¨ä¾‹
const deps: EnrollmentDeps = {
  repo: new EnrollmentRepository(prisma),
  studentSystem: new StudentSystemAdapter(),
  courseSystem: new CourseSystemAdapter(),
  notification: new NotificationService()
};

const command: RequestEnrollmentCommand = {
  studentId: 'ST001',
  courseId: 'CS101',
  semester: '2025-spring'
};

// ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã‚’é©ç”¨ã—ãŸå®Ÿè¡Œ
const executeWithMiddleware = flow(
  requestEnrollmentWithPipe(deps),
  middleware.withLogging('å±¥ä¿®ç”³è«‹å‡¦ç†'),
  middleware.withRetry(3, 1000),
  middleware.withTimeout(30000),
  middleware.withTransaction(deps.repo)
);

// å®Ÿè¡Œ
executeWithMiddleware(command)().then(
  TE.fold(
    (error) => console.error('å‡¦ç†å¤±æ•—:', error),
    (result) => console.log('å‡¦ç†æˆåŠŸ:', result)
  )
);

// ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ä¾‹
describe('pipe ã‚’ä½¿ã£ãŸå±¥ä¿®ç”³è«‹', () => {
  test('æ­£å¸¸ç³»ï¼šã™ã¹ã¦ã®æ¡ä»¶ã‚’æº€ãŸã™å ´åˆ', async () => {
    const mockDeps = createMockDeps({
      studentExists: true,
      courseExists: true,
      prerequisitesSatisfied: true,
      capacityAvailable: true,
      gpaRequirementMet: true,
      noScheduleConflict: true
    });

    const result = await pipe(
      {
        studentId: 'ST001',
        courseId: 'CS101',
        semester: '2025-spring'
      },
      requestEnrollmentWithPipe(mockDeps)
    )();

    expect(result.type).toBe('right');
    if (result.type === 'right') {
      expect(result.value.status).toBe('requested');
      expect(result.value.studentId).toBe('ST001');
    }
  });

  test('ç•°å¸¸ç³»ï¼šå‰æç§‘ç›®æœªä¿®å¾—', async () => {
    const mockDeps = createMockDeps({
      prerequisitesSatisfied: false,
      missingPrerequisites: ['CS100']
    });

    const result = await pipe(
      {
        studentId: 'ST001',
        courseId: 'CS101',
        semester: '2025-spring'
      },
      requestEnrollmentWithPipe(mockDeps)
    )();

    expect(result.type).toBe('left');
    if (result.type === 'left') {
      expect(result.value.rule).toBe('PREREQUISITES_NOT_MET');
    }
  });
});
```

#### application/enrollment-service.ts - å¾“æ¥å‹ã‚µãƒ¼ãƒ“ã‚¹å®Ÿè£…ï¼ˆå‚è€ƒï¼‰

```typescript
export class EnrollmentApplicationService {
  constructor(
    private readonly enrollmentRepo: IEnrollmentRepository,
    private readonly studentSystem: IStudentSystemAdapter,
    private readonly courseSystem: ICourseSystemAdapter,
    private readonly notificationService: INotificationService
  ) {}

  async requestEnrollment(
    command: RequestEnrollmentCommand
  ): Promise<Either<EnrollmentError, EnrollmentDto>> {
    // å…¥åŠ›æ¤œè¨¼
    const studentId = StudentIdSchema.safeParse(command.studentId);
    const courseId = CourseIdSchema.safeParse(command.courseId);
    const semester = SemesterSchema.safeParse(command.semester);

    if (!studentId.success || !courseId.success || !semester.success) {
      return left(createValidationError('ç„¡åŠ¹ãªå…¥åŠ›ã§ã™', 'INVALID_INPUT'));
    }

    return this.enrollmentRepo.withTransaction(async (tx) => {
      // æ—¢å­˜ãƒã‚§ãƒƒã‚¯
      const existing = await tx.findByStudentAndCourseForUpdate(
        studentId.data,
        courseId.data
      );

      if (existing.type === 'left') return left(existing.value);
      if (existing.value !== null) {
        return left(createBusinessRuleError(
          'DUPLICATE_ENROLLMENT',
          'æ—¢ã«å±¥ä¿®ç”³è«‹ã•ã‚Œã¦ã„ã¾ã™',
          'ENROLLMENT_EXISTS'
        ));
      }

      // ä¸¦åˆ—ã§ãƒ“ã‚¸ãƒã‚¹ãƒ«ãƒ¼ãƒ«ãƒã‚§ãƒƒã‚¯
      const [student, course] = await Promise.all([
        this.studentSystem.validateStudent(studentId.data),
        this.courseSystem.getCourseInfo(courseId.data)
      ]);

      if (student.type === 'left') return left(student.value);
      if (course.type === 'left') return left(course.value);

      const [prereq, capacity, gpa, conflict] = await Promise.all([
        this.studentSystem.checkPrerequisites(studentId.data, courseId.data),
        this.courseSystem.checkCapacity(courseId.data),
        course.value.minGPA
          ? this.studentSystem.checkGPARequirement(studentId.data, course.value.minGPA)
          : Promise.resolve(right(true)),
        this.courseSystem.checkScheduleConflict(studentId.data, courseId.data)
      ]);

      // ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯
      for (const result of [prereq, capacity, gpa, conflict]) {
        if (result.type === 'left') return left(result.value);
      }

      // ãƒ“ã‚¸ãƒã‚¹ãƒ«ãƒ¼ãƒ«é•åãƒã‚§ãƒƒã‚¯
      if (!prereq.value.satisfied) {
        return left(createBusinessRuleError(
          'PREREQUISITES_NOT_MET',
          `å‰æç§‘ç›®ãŒä¸è¶³: ${prereq.value.missing.join(', ')}`,
          'MISSING_PREREQUISITES'
        ));
      }

      if (!capacity.value.available) {
        return left(createBusinessRuleError(
          'COURSE_FULL',
          'å®šå“¡ã«é”ã—ã¦ã„ã¾ã™',
          'NO_CAPACITY'
        ));
      }

      if (!gpa.value) {
        return left(createBusinessRuleError(
          'GPA_REQUIREMENT_NOT_MET',
          `GPAè¦ä»¶æœªé”ï¼ˆå¿…è¦: ${course.value.minGPA}ï¼‰`,
          'LOW_GPA'
        ));
      }

      if (conflict.value) {
        return left(createBusinessRuleError(
          'SCHEDULE_CONFLICT',
          'å—è¬›æ™‚é–“ãŒé‡è¤‡ã—ã¦ã„ã¾ã™',
          'TIME_CONFLICT'
        ));
      }

      // å±¥ä¿®ç”³è«‹ä½œæˆ
      const enrollmentResult = requestEnrollment(
        studentId.data,
        courseId.data,
        semester.data
      );

      if (enrollmentResult.type === 'left') return left(enrollmentResult.value);

      const { domainEvent, ...enrollment } = enrollmentResult.value;

      // æ°¸ç¶šåŒ–
      const saveResult = await tx.save(enrollment, domainEvent);
      if (saveResult.type === 'left') return left(saveResult.value);

      // é€šçŸ¥ï¼ˆéåŒæœŸï¼‰
      this.notificationService
        .notifyEnrollmentRequested(studentId.data, courseId.data)
        .catch(err => console.error('é€šçŸ¥é€ä¿¡ã‚¨ãƒ©ãƒ¼:', err));

      return right(toEnrollmentDto(enrollment));
    });
  }

  async approveEnrollment(
    command: ApproveEnrollmentCommand
  ): Promise<Either<EnrollmentError, EnrollmentDto>> {
    const studentId = StudentIdSchema.safeParse(command.studentId);
    const courseId = CourseIdSchema.safeParse(command.courseId);

    if (!studentId.success || !courseId.success) {
      return left(createValidationError('ç„¡åŠ¹ãªå…¥åŠ›ã§ã™', 'INVALID_INPUT'));
    }

    return this.enrollmentRepo.withTransaction(async (tx) => {
      const enrollment = await tx.findByStudentAndCourseForUpdate(
        studentId.data,
        courseId.data
      );

      if (enrollment.type === 'left') return left(enrollment.value);
      if (enrollment.value === null) {
        return left(createNotFoundError(
          'Enrollment',
          `${studentId.data}-${courseId.data}`
        ));
      }

      const approval = safeApproveEnrollment(enrollment.value, command.approvedBy);
      if (approval.type === 'left') return left(approval.value);

      const { domainEvent, ...updated } = approval.value;

      const saveResult = await tx.save(updated, domainEvent);
      if (saveResult.type === 'left') return left(saveResult.value);

      this.notificationService
        .notifyEnrollmentApproved(studentId.data, courseId.data, command.approvedBy)
        .catch(err => console.error('é€šçŸ¥é€ä¿¡ã‚¨ãƒ©ãƒ¼:', err));

      return right(toEnrollmentDto(updated));
    });
  }

  async cancelEnrollment(
    command: CancelEnrollmentCommand
  ): Promise<Either<EnrollmentError, EnrollmentDto>> {
    const studentId = StudentIdSchema.safeParse(command.studentId);
    const courseId = CourseIdSchema.safeParse(command.courseId);

    if (!studentId.success || !courseId.success) {
      return left(createValidationError('ç„¡åŠ¹ãªå…¥åŠ›ã§ã™', 'INVALID_INPUT'));
    }

    return this.enrollmentRepo.withTransaction(async (tx) => {
      const enrollment = await tx.findByStudentAndCourseForUpdate(
        studentId.data,
        courseId.data
      );

      if (enrollment.type === 'left') return left(enrollment.value);
      if (enrollment.value === null) {
        return left(createNotFoundError(
          'Enrollment',
          `${studentId.data}-${courseId.data}`
        ));
      }

      const cancel = safeCancelEnrollment(enrollment.value, command.reason);
      if (cancel.type === 'left') return left(cancel.value);

      const { domainEvent, ...updated } = cancel.value;

      const saveResult = await tx.save(updated, domainEvent);
      if (saveResult.type === 'left') return left(saveResult.value);

      this.notificationService
        .notifyEnrollmentCancelled(studentId.data, courseId.data, command.reason)
        .catch(err => console.error('é€šçŸ¥é€ä¿¡ã‚¨ãƒ©ãƒ¼:', err));

      return right(toEnrollmentDto(updated));
    });
  }

  async completeEnrollment(
    command: CompleteEnrollmentCommand
  ): Promise<Either<EnrollmentError, EnrollmentDto>> {
    const studentId = StudentIdSchema.safeParse(command.studentId);
    const courseId = CourseIdSchema.safeParse(command.courseId);

    if (!studentId.success || !courseId.success) {
      return left(createValidationError('ç„¡åŠ¹ãªå…¥åŠ›ã§ã™', 'INVALID_INPUT'));
    }

    return this.enrollmentRepo.withTransaction(async (tx) => {
      const enrollment = await tx.findByStudentAndCourseForUpdate(
        studentId.data,
        courseId.data
      );

      if (enrollment.type === 'left') return left(enrollment.value);
      if (enrollment.value === null) {
        return left(createNotFoundError(
          'Enrollment',
          `${studentId.data}-${courseId.data}`
        ));
      }

      const complete = safeCompleteEnrollment(enrollment.value);
      if (complete.type === 'left') return left(complete.value);

      const { domainEvent, ...updated } = complete.value;

      const saveResult = await tx.save(updated, domainEvent);
      if (saveResult.type === 'left') return left(saveResult.value);

      return right(toEnrollmentDto(updated));
    });
  }

  async failEnrollment(
    command: FailEnrollmentCommand
  ): Promise<Either<EnrollmentError, EnrollmentDto>> {
    const studentId = StudentIdSchema.safeParse(command.studentId);
    const courseId = CourseIdSchema.safeParse(command.courseId);

    if (!studentId.success || !courseId.success) {
      return left(createValidationError('ç„¡åŠ¹ãªå…¥åŠ›ã§ã™', 'INVALID_INPUT'));
    }

    return this.enrollmentRepo.withTransaction(async (tx) => {
      const enrollment = await tx.findByStudentAndCourseForUpdate(
        studentId.data,
        courseId.data
      );

      if (enrollment.type === 'left') return left(enrollment.value);
      if (enrollment.value === null) {
        return left(createNotFoundError(
          'Enrollment',
          `${studentId.data}-${courseId.data}`
        ));
      }

      const fail = safeFailEnrollment(enrollment.value);
      if (fail.type === 'left') return left(fail.value);

      const { domainEvent, ...updated } = fail.value;

      const saveResult = await tx.save(updated, domainEvent);
      if (saveResult.type === 'left') return left(saveResult.value);

      return right(toEnrollmentDto(updated));
    });
  }

  async getEnrollment(
    studentId: string,
    courseId: string
  ): Promise<Either<EnrollmentError, EnrollmentDto | null>> {
    const studentIdResult = StudentIdSchema.safeParse(studentId);
    const courseIdResult = CourseIdSchema.safeParse(courseId);

    if (!studentIdResult.success || !courseIdResult.success) {
      return left(createValidationError('ç„¡åŠ¹ãªå…¥åŠ›ã§ã™', 'INVALID_INPUT'));
    }

    const result = await this.enrollmentRepo.findByStudentAndCourse(
      studentIdResult.data,
      courseIdResult.data
    );

    if (result.type === 'left') return left(result.value);
    return right(result.value ? toEnrollmentDto(result.value) : null);
  }

  async getStudentEnrollments(
    studentId: string
  ): Promise<Either<EnrollmentError, EnrollmentListDto>> {
    const studentIdResult = StudentIdSchema.safeParse(studentId);

    if (!studentIdResult.success) {
      return left(createValidationError(
        'ç„¡åŠ¹ãªå­¦ç”ŸIDã§ã™',
        'INVALID_STUDENT_ID'
      ));
    }

    const result = await this.enrollmentRepo.findByStudent(studentIdResult.data);
    if (result.type === 'left') return left(result.value);

    const enrollments = result.value.map(toEnrollmentDto);
    return right({ enrollments, total: enrollments.length });
  }

  async getEnrollmentHistory(
    studentId: string,
    courseId: string
  ): Promise<Either<EnrollmentError, EnrollmentDto | null>> {
    const studentIdResult = StudentIdSchema.safeParse(studentId);
    const courseIdResult = CourseIdSchema.safeParse(courseId);

    if (!studentIdResult.success || !courseIdResult.success) {
      return left(createValidationError('ç„¡åŠ¹ãªå…¥åŠ›ã§ã™', 'INVALID_INPUT'));
    }

    const eventsResult = await this.enrollmentRepo.getEventHistory(
      studentIdResult.data,
      courseIdResult.data
    );

    if (eventsResult.type === 'left') return left(eventsResult.value);

    const enrollmentResult = reconstructEnrollmentFromEvents(eventsResult.value);
    if (enrollmentResult.type === 'left') return left(enrollmentResult.value);

    return right(
      enrollmentResult.value ? toEnrollmentDto(enrollmentResult.value) : null
    );
  }
}
```

### 3. ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£å±¤

#### infrastructure/prisma/schema.prisma

```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// === é›†ç´„ãƒ«ãƒ¼ãƒˆï¼ˆINSERT ONLYï¼‰ ===
model Enrollment {
  studentId  String   @map("student_id")
  courseId   String   @map("course_id")
  createdAt  DateTime @default(now()) @map("created_at")

  domainEvents DomainEvent[]

  @@id([studentId, courseId])
  @@map("enrollments")
}

// === ã‚¤ãƒ™ãƒ³ãƒˆã‚¹ãƒˆã‚¢ ===
model DomainEvent {
  studentId   String   @map("student_id")
  courseId    String   @map("course_id")
  eventType   String   @map("event_type")
  version     Int
  occurredAt  DateTime @map("occurred_at")
  createdAt   DateTime @default(now()) @map("created_at")

  enrollment   Enrollment @relation(fields: [studentId, courseId], references: [studentId, courseId])

  enrollmentRequestedEvent  EnrollmentRequestedEvent?
  enrollmentApprovedEvent   EnrollmentApprovedEvent?
  enrollmentCancelledEvent  EnrollmentCancelledEvent?
  enrollmentCompletedEvent  EnrollmentCompletedEvent?
  enrollmentFailedEvent     EnrollmentFailedEvent?

  @@id([studentId, courseId, version])
  @@index([studentId, courseId])
  @@map("domain_events")
}

// === ã‚¤ãƒ™ãƒ³ãƒˆè©³ç´°ãƒ†ãƒ¼ãƒ–ãƒ« ===
model EnrollmentRequestedEvent {
  studentId   String   @map("student_id")
  courseId    String   @map("course_id")
  version     Int
  semester    String   @map("semester")
  requestedAt DateTime @map("requested_at")

  domainEvent DomainEvent @relation(fields: [studentId, courseId, version], references: [studentId, courseId, version], onDelete: Cascade)

  @@id([studentId, courseId, version])
  @@map("enrollment_requested_events")
}

model EnrollmentApprovedEvent {
  studentId  String   @map("student_id")
  courseId   String   @map("course_id")
  version    Int
  approvedAt DateTime @map("approved_at")
  approvedBy String   @map("approved_by")

  domainEvent DomainEvent @relation(fields: [studentId, courseId, version], references: [studentId, courseId, version], onDelete: Cascade)

  @@id([studentId, courseId, version])
  @@map("enrollment_approved_events")
}

model EnrollmentCancelledEvent {
  studentId   String   @map("student_id")
  courseId    String   @map("course_id")
  version     Int
  cancelledAt DateTime @map("cancelled_at")
  reason      String   @map("reason")
  wasApproved Boolean  @default(false) @map("was_approved")

  domainEvent DomainEvent @relation(fields: [studentId, courseId, version], references: [studentId, courseId, version], onDelete: Cascade)

  @@id([studentId, courseId, version])
  @@map("enrollment_cancelled_events")
}

model EnrollmentCompletedEvent {
  studentId   String   @map("student_id")
  courseId    String   @map("course_id")
  version     Int
  completedAt DateTime @map("completed_at")

  domainEvent DomainEvent @relation(fields: [studentId, courseId, version], references: [studentId, courseId, version], onDelete: Cascade)

  @@id([studentId, courseId, version])
  @@map("enrollment_completed_events")
}

model EnrollmentFailedEvent {
  studentId String   @map("student_id")
  courseId  String   @map("course_id")
  version   Int
  failedAt  DateTime @map("failed_at")

  domainEvent DomainEvent @relation(fields: [studentId, courseId, version], references: [studentId, courseId, version], onDelete: Cascade)

  @@id([studentId, courseId, version])
  @@map("enrollment_failed_events")
}
```

#### infrastructure/repositories/enrollment-repository.tsï¼ˆç°¡æ½”ç‰ˆï¼‰

```typescript
import { PrismaClient, Prisma } from '@prisma/client';
import {
  IEnrollmentRepository, ITransactionContext
} from '../../application/ports';
import {
  Either, left, right, Enrollment, StudentId, CourseId
} from '../../domain/types';
import { EnrollmentDomainEvent } from '../../domain/domain-events';
import {
  EnrollmentError, createValidationError, createConcurrencyError
} from '../../domain/errors';
import { reconstructEnrollmentFromEvents } from '../../domain/enrollment-aggregate';

export class EnrollmentRepository implements IEnrollmentRepository {
  constructor(private readonly prisma: PrismaClient) {}

  async findByStudentAndCourse(
    studentId: StudentId,
    courseId: CourseId
  ): Promise<Either<EnrollmentError, Enrollment | null>> {
    try {
      const events = await this.getEvents(studentId, courseId);
      if (events.length === 0) return right(null);

      const domainEvents = this.toDomainEvents(events);
      return reconstructEnrollmentFromEvents(domainEvents);
    } catch (error) {
      return left(createValidationError(
        `DBã‚¨ãƒ©ãƒ¼: ${error}`,
        'DATABASE_ERROR'
      ));
    }
  }

  async findByStudent(
    studentId: StudentId
  ): Promise<Either<EnrollmentError, Enrollment[]>> {
    try {
      const records = await this.prisma.enrollment.findMany({
        where: { studentId }
      });

      const enrollments: Enrollment[] = [];
      for (const record of records) {
        const result = await this.findByStudentAndCourse(
          record.studentId,
          record.courseId
        );
        if (result.type === 'left') return left(result.value);
        if (result.value) enrollments.push(result.value);
      }

      return right(enrollments);
    } catch (error) {
      return left(createValidationError(
        `DBã‚¨ãƒ©ãƒ¼: ${error}`,
        'DATABASE_ERROR'
      ));
    }
  }

  async getEventHistory(
    studentId: StudentId,
    courseId: CourseId
  ): Promise<Either<EnrollmentError, EnrollmentDomainEvent[]>> {
    try {
      const events = await this.getEvents(studentId, courseId);
      return right(this.toDomainEvents(events));
    } catch (error) {
      return left(createValidationError(
        `DBã‚¨ãƒ©ãƒ¼: ${error}`,
        'DATABASE_ERROR'
      ));
    }
  }

  async save(
    enrollment: Enrollment,
    event: EnrollmentDomainEvent
  ): Promise<Either<EnrollmentError, void>> {
    try {
      await this.prisma.$transaction(async (tx) => {
        // é›†ç´„ãƒ«ãƒ¼ãƒˆå­˜åœ¨ãƒã‚§ãƒƒã‚¯
        const existing = await tx.enrollment.findUnique({
          where: {
            studentId_courseId: {
              studentId: enrollment.studentId,
              courseId: enrollment.courseId
            }
          }
        });

        if (!existing) {
          await tx.enrollment.create({
            data: {
              studentId: enrollment.studentId,
              courseId: enrollment.courseId
            }
          });
        }

        await this.saveEvent(tx, event);
      });

      return right(undefined);
    } catch (error: any) {
      if (error.code === 'P2002' && error.meta?.target?.includes('version')) {
        return left(createConcurrencyError(
          event.version,
          event.version,
          enrollment.studentId,
          enrollment.courseId
        ));
      }
      return left(createValidationError(`ä¿å­˜ã‚¨ãƒ©ãƒ¼: ${error}`, 'SAVE_ERROR'));
    }
  }

  async withTransaction<T>(
    fn: (tx: ITransactionContext) => Promise<T>
  ): Promise<T> {
    return this.prisma.$transaction(async (tx) => {
      const context = new TransactionContext(tx as PrismaClient);
      return fn(context);
    });
  }

  // === Private Methods ===
  private async getEvents(studentId: string, courseId: string) {
    return this.prisma.domainEvent.findMany({
      where: { studentId, courseId },
      orderBy: { version: 'asc' },
      include: {
        enrollmentRequestedEvent: true,
        enrollmentApprovedEvent: true,
        enrollmentCancelledEvent: true,
        enrollmentCompletedEvent: true,
        enrollmentFailedEvent: true
      }
    });
  }

  private toDomainEvents(events: any[]): EnrollmentDomainEvent[] {
    return events.map(event => {
      const base = {
        studentId: event.studentId,
        courseId: event.courseId,
        eventType: event.eventType,
        occurredAt: event.occurredAt,
        version: event.version
      };

      switch (event.eventType) {
        case 'EnrollmentRequested':
          return {
            ...base,
            eventType: 'EnrollmentRequested',
            semester: event.enrollmentRequestedEvent.semester,
            requestedAt: event.enrollmentRequestedEvent.requestedAt
          } as EnrollmentDomainEvent;

        case 'EnrollmentApproved':
          return {
            ...base,
            eventType: 'EnrollmentApproved',
            approvedAt: event.enrollmentApprovedEvent.approvedAt,
            approvedBy: event.enrollmentApprovedEvent.approvedBy
          } as EnrollmentDomainEvent;

        case 'EnrollmentCancelled':
          return {
            ...base,
            eventType: 'EnrollmentCancelled',
            cancelledAt: event.enrollmentCancelledEvent.cancelledAt,
            reason: event.enrollmentCancelledEvent.reason,
            wasApproved: event.enrollmentCancelledEvent.wasApproved
          } as EnrollmentDomainEvent;

        case 'EnrollmentCompleted':
          return {
            ...base,
            eventType: 'EnrollmentCompleted',
            completedAt: event.enrollmentCompletedEvent.completedAt
          } as EnrollmentDomainEvent;

        case 'EnrollmentFailed':
          return {
            ...base,
            eventType: 'EnrollmentFailed',
            failedAt: event.enrollmentFailedEvent.failedAt
          } as EnrollmentDomainEvent;

        default:
          throw new Error(`Unknown event type: ${event.eventType}`);
      }
    });
  }

  private async saveEvent(
    tx: Prisma.TransactionClient,
    event: EnrollmentDomainEvent
  ): Promise<void> {
    await tx.domainEvent.create({
      data: {
        studentId: event.studentId,
        courseId: event.courseId,
        eventType: event.eventType,
        version: event.version,
        occurredAt: event.occurredAt
      }
    });

    switch (event.eventType) {
      case 'EnrollmentRequested':
        await tx.enrollmentRequestedEvent.create({
          data: {
            studentId: event.studentId,
            courseId: event.courseId,
            version: event.version,
            semester: event.semester,
            requestedAt: event.requestedAt
          }
        });
        break;

      case 'EnrollmentApproved':
        await tx.enrollmentApprovedEvent.create({
          data: {
            studentId: event.studentId,
            courseId: event.courseId,
            version: event.version,
            approvedAt: event.approvedAt,
            approvedBy: event.approvedBy
          }
        });
        break;

      case 'EnrollmentCancelled':
        await tx.enrollmentCancelledEvent.create({
          data: {
            studentId: event.studentId,
            courseId: event.courseId,
            version: event.version,
            cancelledAt: event.cancelledAt,
            reason: event.reason,
            wasApproved: event.wasApproved
          }
        });
        break;

      case 'EnrollmentCompleted':
        await tx.enrollmentCompletedEvent.create({
          data: {
            studentId: event.studentId,
            courseId: event.courseId,
            version: event.version,
            completedAt: event.completedAt
          }
        });
        break;

      case 'EnrollmentFailed':
        await tx.enrollmentFailedEvent.create({
          data: {
            studentId: event.studentId,
            courseId: event.courseId,
            version: event.version,
            failedAt: event.failedAt
          }
        });
        break;
    }
  }
}

// ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆå®Ÿè£…
class TransactionContext implements ITransactionContext {
  constructor(private readonly tx: PrismaClient) {}

  async findByStudentAndCourseForUpdate(
    studentId: StudentId,
    courseId: CourseId
  ): Promise<Either<EnrollmentError, Enrollment | null>> {
    const repo = new EnrollmentRepository(this.tx);
    return repo.findByStudentAndCourse(studentId, courseId);
  }

  async save(
    enrollment: Enrollment,
    event: EnrollmentDomainEvent
  ): Promise<Either<EnrollmentError, void>> {
    const repo = new EnrollmentRepository(this.tx);
    return repo.save(enrollment, event);
  }
}
```

### 4. ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰

#### tests/domain/enrollment-aggregate.test.tsï¼ˆä¸»è¦éƒ¨åˆ†ï¼‰

```typescript
import { describe, test, expect } from '@jest/globals';
import {
  requestEnrollment, approveEnrollment, safeCancelEnrollment,
  updateWithVersionCheck, reconstructEnrollmentFromEvents
} from '../../src/domain/enrollment-aggregate';
import { createRequestedEnrollment, isRequested } from '../../src/domain/types';
import { createEnrollmentRequestedEvent } from '../../src/domain/domain-events';

describe('Enrollment Aggregate', () => {
  const studentId = 'ST001' as any; // ãƒ–ãƒ©ãƒ³ãƒ‰å‹ã®ã‚­ãƒ£ã‚¹ãƒˆ
  const courseId = 'CS101' as any;
  const semester = '2025-spring' as any;

  describe('çŠ¶æ…‹é·ç§»', () => {
    test('å±¥ä¿®ç”³è«‹ã®ä½œæˆ', () => {
      const result = requestEnrollment(studentId, courseId, semester);

      expect(result.type).toBe('right');
      if (result.type === 'right') {
        expect(result.value.status).toBe('requested');
        expect(result.value.version).toBe(1);
        expect(result.value.domainEvent.eventType).toBe('EnrollmentRequested');
      }
    });

    test('ç”³è«‹â†’æ‰¿èª', () => {
      const requested = createRequestedEnrollment(studentId, courseId, semester);
      const result = approveEnrollment(requested, 'admin001');

      expect(result.type).toBe('right');
      if (result.type === 'right') {
        expect(result.value.status).toBe